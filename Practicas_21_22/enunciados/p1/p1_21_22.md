
# PrÃ¡ctica Individual 1 â€“ Ejercicios iterativos, recursivos lineales y notaciÃ³n funcional

## Ejemplos

1. Dado el siguiente cÃ³digo  encontrar su equivalente iterativo y funcional.

```java
public static String ejemplo1(Integer a, Integer b,
	Function<Integer,Integer> f, String sp, String pf, String sf){
		return Stream.iterate(a, x->x<=b, x -> f.apply(x))
		.map(x->x*x)
		.map(x->x.toString())
		.collect(Collectors.joining(sp,pf,sf));
}
```
2. Un Punto es un tipo con las siguientes propiedades:
	- X, Double, bÃ¡sica, individual
	- Y, Double, bÃ¡sica, individual
	- Cuadrante, Cuadrante, derivada, individual. 
	Enumerado {PRIMER_CUADRANTE, SEGUNDO_CUADRANTE,
TERCER_CUADRANTE, CUARTO_CUADRANTE}.

```java
public static Map<Punto2D.Cuadrante,Double> ejemplo2(List<Punto2D> ls){
	return ls.stream()
		.collect(Collectors.groupingBy(Punto2D::getCuadrante,
			Collectors.reducing(0.,x->x.x(),(x,y)->x+y)));
}
```

3. Dadas 2 cadenas de caracteres A y B de la misma longitud, que cumplen que son iguales
carÃ¡cter a carÃ¡cter hasta una determinada posiciÃ³n y distintas carÃ¡cter a carÃ¡cter a partir
de dicha posiciÃ³n, determinar la primera posiciÃ³n en la que A y B son distintos. Por
ejemplo A = â€œbuenosdiaspepeâ€ y B = â€œbuenosdiasjuanâ€, devolverÃ­a la posiciÃ³n 10.

4. Siendo n de tipo entero y a de tipo Long, calcular $a^n$ a partir de la propiedad:

$$

a^n = 
\left\{
 \begin{array}{rl}
  1, &  n = 0 \\
   {(a^{n/2})}^2 a, & n \gt 0 \ \land \ n\%2 = 1 \\
   {(a^{n/2})}^2, & n \gt 0 \ \land \ n\%2 = 0 \\
 \end{array}
\right.
$$
## Ejercicios



1.
```java
public static boolean ejercicio1(List<String> ls, Predicate<String> pS,
Predicate<Integer> pI, Function<String,Integer> f){
	 return ls.stream()
		.filter(pS)
		.map(f)
		.anyMatch(pI);
}
```
2. 
```java
public static Map<Integer,List<String>> ejercicio2 (List<List<String>> listas) {
	 return listas.stream()
		.flatMap(lista -> lista.stream())
		.collect(Collectors.groupingBy(String::length));
}
```
3. 
```java
public static String ejercicio3(Integer a, Integer limit) {
	 return Stream.iterate(Par.of(0, a),
			  t -> t.v1 < limit,
			 t -> Par.of(t.v1+1, t.v1 % 3 == 1 ? t.v2 : t.v1+t.v2))
		.collect(Collectors.toList())
		.toString();
}
```
donde Par es una clase con 2 propiedades enteras v1 y v2, la cual debe implementar como
un record.

4. DiseÃ±e un algoritmo que dados dos nÃºmeros n y e (con n real positivo mayor que 1 y
e real en el intervalo $[0,1)$), devuelva un nÃºmero real que se corresponda con la raÃ­z cÃºbica
de n con un error menor que e.

5. Dada la siguiente definiciÃ³n recursiva de la funciÃ³n f (que toma como entrada 3
nÃºmeros enteros positivos y devuelve una cadena):
$$
ğ‘“(ğ‘, ğ‘, ğ‘) =  
\left\{
 \begin{array}{rl}
\text{"("} + ğ‘¡ğ‘œğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”(ğ‘ âˆ— ğ‘ âˆ— ğ‘) + \text{")"}, & ğ‘ < 3 \lor ğ‘ < 3 \lor ğ‘ < 3 \\
\text{"("} + ğ‘¡ğ‘œğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”(ğ‘ + ğ‘ + ğ‘) + ")", & ğ‘ < 5 \lor ğ‘ < 5 \lor ğ‘ < 5 \\
ğ‘¡ğ‘œğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”(ğ‘ âˆ— ğ‘ âˆ— ğ‘) + ğ‘“(ğ‘/2, ğ‘ âˆ’ 2, ğ‘/2), & ğ‘ \ \text{ğ‘’ğ‘  ğ‘ğ‘ğ‘Ÿ} \land ğ‘ \ \text{ğ‘’ğ‘  ğ‘ğ‘ğ‘Ÿ} \land ğ‘ \ \text{ğ‘’ğ‘  ğ‘ğ‘ğ‘Ÿ} \\
ğ‘¡ğ‘œğ‘†ğ‘¡ğ‘Ÿğ‘–ğ‘›ğ‘”(ğ‘ + ğ‘ + ğ‘) + ğ‘“(ğ‘/3, ğ‘ âˆ’ 3, ğ‘/3), & \text{ğ‘’ğ‘› ğ‘œğ‘¡ğ‘Ÿğ‘œ ğ‘ğ‘ğ‘ ğ‘œ}
\end{array}
\right.
$$
siendo + un operador que representa la concatenaciÃ³n de cadenas, y toString(i) un mÃ©todo
que devuelve una cadena a partir de un entero. Al llevar a cabo la implementaciÃ³n, para
el tratamiento de cadenas se recomienda hacer uso de String.format